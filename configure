#!/usr/bin/env python3

# this is a convenience script that will simply create a build directory and
# invoke cmake.

import argparse
import multiprocessing
import os
import subprocess
import shutil
import shlex
shlex.join = lambda args: ' '.join(shlex.quote(a) for a in args)


def getenv(*varnames, default=""):
    """
    fetches an environment variable.
    tries all given varnames until it finds an existing one.
    if none fits, returns default.
    """
    for v in varnames:
        if v in os.environ:
            return os.environ[v]

    return default


class AliasedChoices:
    """
    for use with argparse.choices.
    allows the user a bit more freedums,
    such as writing 'dbg' instead of 'debug'.
    """
    def __init__(self, *choices):
        self.choices = [choice[0] for choice in choices]

        # build reverse-lookup dict
        self.aliases = {alias.lower(): choice[0]
                        for choice in choices
                        for alias in choice
}

    def __iter__(self):
        return iter(self.choices)

    def __contains__(self, alias):
        return alias.lower() in self.aliases

    def lookup(self, alias):
        return self.aliases[alias.lower()]


modes = AliasedChoices(
    ("debug", "dbg"),        # -g
    ("release", "rls")       # -DNDEBUG
)

omodes = AliasedChoices(
    ("auto", ""),            # auto-determine from mode
    ("0", "none"),           # -O0; not recommended
    ("1",),                  # -O1; not recommended
    ("g", "dbg", "debug"),   # -Og / -O1 depending on compiler support
    ("2", "rls", "release"), # -O2; recommended for release
    ("max", "3"),            # -O3 -flto -march=native
)

# argparsing
description = "convenience script to create a build directory "
description += "and invoke cmake."
epilog = "environment variables like CXX and CXXFLAGS are honored, "
epilog += "but overwritten if their respective arguments are specified."

ap = argparse.ArgumentParser(
    description=description,
    epilog=epilog,
    formatter_class=argparse.ArgumentDefaultsHelpFormatter)

ap.add_argument("--mode", "-m", choices=["debug",
                                         "release"],
                default="release",
                help="controls cmake build mode")
ap.add_argument("--optimize", "-O", choices=["auto",
                                             "0",
                                             "1",
                                             "g",
                                             "2",
                                             "max"], default="auto",
                help="controls optimization-related flags. " +
                     "is set according to mode if 'auto'. " +
                     "conflicts with --flags")
ap.add_argument("--compiler", "-c",
                default=getenv("CXX", "CC", default="gnu"),
                help="compiler suite")
ap.add_argument("--flags", "-f",
                default=getenv("CXXFLAGS", "CCFLAGS", "CFLAGS"),
                help="compiler flags")
ap.add_argument("--ldflags", "-l",
                default=getenv("LDFLAGS"),
                help="linker flags")
ap.add_argument("--prefix", "-p", default="/usr/local",
                help="installation directory prefix")

args = ap.parse_args()

try:
    subprocess.call(['cowsay', 'openage configure helper'])
    print('')
except:
    pass

defines = {}

# args.mode
mode = modes.lookup(args.mode)
if mode == 'debug':
    build_type = 'Debug'
else:
    build_type = 'Release'
defines.update(build_type=build_type)

omode = omodes.lookup(args.optimize)

# args.flags, args.ldflags
flags = shlex.split(args.flags)
ldflags = shlex.split(args.ldflags)

if omode == 'auto':
    if mode == 'debug':
        omode = 'g'
    else:
        omode = '2'
else:
    if flags:
        ap.error("--optimize is forbidden when flags are specified manually " +
                 "(conflicting: -O%s, -f %s)" % (omode, shlex.join(flags)))

cxx_lookup = {
    "clang": "clang++",
    "gcc": "g++",
}

cc = cxx = cname = None
if args.compiler.lower() in {'clang', 'clang++', 'llvm'}:
    cc = cname = "clang"
    cxx = cxx_lookup[cc]
elif args.compiler.lower() in {'gcc', 'g++', 'gnu'}:
    cc = cname = "gcc"
    cxx = cxx_lookup[cc]
elif not args.compiler:
    ap.error("no compiler was specified")
else:
    # the user decided to use some sort of custom compiler
    # what could possibly go wrong?

    try:
        cc, cxx = args.compiler.split(',')
    except ValueError:
        ap.error("unknown compiler name: %s\n" % args.compiler +
                 "specify manual invocations for both CC and CXX as $CC,$CXX")

    if "gcc" in cc:
        cname = "gcc"
    if "clang" in cc:
        cname = "clang"
    else:
        cname = cc.split(os.path.sep)[-1].split("-")[0]
        if not cname:
            cname = "unknown"

if not shutil.which(cc):
    ap.error("could not find CC executable: %s" % cc)
if not shutil.which(cxx):
    ap.error("could not find CXX executable: %s" % cxx)

defines.update(c_compiler=cc, cxx_compiler=cxx)

# if no flags have been given, populate them from the other args
if not flags and not ldflags:
    if omode == '0':
        flags.append("-O0")
    elif omode == '1':
        flags.append("-O1")
    elif omode == 'g':
        if cname in {'gcc'}:
            flags.append("-Og")
        else:
            flags.append("-O1")
    elif omode == '2':
        flags.append("-O2")
    elif omode == 'max':
        flags.append("-O3")
        flags.append("-march=native")

        if cname in {'gcc'}:
            flags.append("-flto=%d" % multiprocessing.cpu_count())
            ldflags.append("-flto=%d" % multiprocessing.cpu_count())

flags = shlex.join(flags)
ldflags = shlex.join(ldflags)
defines.update(c_flags=flags, cxx_flags=flags, exe_linker_flags=ldflags,
               module_linker_flags=ldflags, shared_linker_flags=ldflags)

# args.prefix
defines.update(install_prefix=args.prefix)

def sanitize(s, fallback='-'):
    """
    sanitizes a string for safe usage in a filename
    """

    def yieldsanitizedchars():
        # False if the previous char was regular.
        fallingback = True
        for c in s:
            if c == fallback and fallingback:
                fallingback = False
            elif c.isalnum() or c in "+-_=,":
                fallingback = False
                yield c
            elif not fallingback:
                fallingback = True
                yield fallback

    return "".join(yieldsanitizedchars())

bindir = ".bin/%s-%s-%s" % (sanitize(cc), sanitize(mode), sanitize(flags))
os.makedirs(bindir, exist_ok=True)


def forcesymlink(linkto, name):
    """
    similar in function to ln -sf
    """
    try:
        os.unlink(name)
    except FileNotFoundError:
        pass

    os.symlink(linkto, name)

# create the build dir and symlink it to 'bin'
forcesymlink(bindir, 'bin')
forcesymlink('%s/cpp/openage' % bindir, 'openage')

# the project root directory contains this configure file.
project_root = os.path.dirname(os.path.realpath(__file__))

# calculate cmake invocation from defines dict
invocation = ['cmake']
maxkeylen = max(len(k) for k in defines)
for k, v in sorted(defines.items()):
    print('%s | %s' % (k.rjust(maxkeylen), v))

    if k in ('c_compiler', 'cxx_compiler'):
        # work around this cmake 'feature':
        # when run in an existing build directory, if CC or CXX are given,
        # all other arguments are ignored... this is retarded.
        if os.path.exists(os.path.join(bindir, 'CMakeCache.txt')):
            continue

    invocation.append('-DCMAKE_%s=%s' % (k.upper(), shlex.quote(v)))

invocation.append('--')
invocation.append(project_root)

# switch to build directory
print('\nbindir:\n%s/\n' % os.path.join(project_root, bindir))
os.chdir(bindir)

# invoke cmake
try:
    print('invocation:\n%s\n' % ' '.join(invocation))
    exit(subprocess.call(invocation))
except FileNotFoundError:
    print("cmake was not found")
    exit(1)
