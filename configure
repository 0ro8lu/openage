#!/usr/bin/env python3

# this is a convenience script that will simply create a build directory and
# invoke cmake.

import argparse
from multiprocessing import cpu_count
import os
import subprocess
import shutil
import shlex
shlex.join = lambda args: ' '.join(shlex.quote(a) for a in args)


def getenv(*varnames, default=""):
    """
    fetches an environment variable.
    tries all given varnames until it finds an existing one.
    if none fits, returns default.
    """
    for v in varnames:
        if v in os.environ:
            return os.environ[v]

    return default


# argparsing
description = "convenience script to create a build directory "
description += "and invoke cmake."
epilog = "environment variables like CXX and CXXFLAGS are honored, "
epilog += "but overwritten if their respective arguments are specified."

ap = argparse.ArgumentParser(description=description, epilog=epilog)
ap.add_argument("--mode", "-m", choices=["debug", "release",
                "excessively_optimized"], default="release",
                help="controls cmake build mode and some compiler flags")
ap.add_argument("--compiler", "-c",
                default=getenv("CXX", "CC", default="g++"),
                help="the c++ compiler to use: e.g. clang++, g++")
ap.add_argument("--flags", "-f",
                default=getenv("CXXFLAGS", "CCFLAGS", "CFLAGS"),
                help="compiler flags")
ap.add_argument("--ldflags", "-l",
                default=getenv("LDFLAGS"),
                help="linker flags")
ap.add_argument("--prefix", "-p", default="/usr/local",
                help="installation directory prefix, e.g. /usr/games")

args = ap.parse_args()

try:
    subprocess.call(['cowsay', 'openage configure helper'])
    print('')
except:
    pass

defines = {}

# args.mode
mode = args.mode
if mode == 'debug':
    build_type = 'Debug'
else:
    build_type = 'Release'
defines.update(build_type=build_type)


c_compiler = {
    "clang++": "clang",
    "g++": "gcc",
}

cc, cxx = None, None
if args.compiler.lower() in {'clang', 'clang++', 'llvm'}:
    cxx = 'clang++'
    c_name = cxx
    cc = c_compiler[cxx]
elif args.compiler.lower() in {'gcc', 'g++', 'gnu'}:
    cxx = 'g++'
    c_name = cxx
    cc = c_compiler[cxx]
else:
    if not args.compiler:
        raise Exception("invalid compiler selected")

    # try to figure out whether CXX or CC was passed.

    print("WARNING: unknown compiler name: '%s'\n" % (args.compiler))

    # split up filename on directory delimiters
    c_path = args.compiler.rsplit("/", 1)

    if "-" in c_path[-1]:
        c_id, c_version = c_path[-1].rsplit("-", 1)
    else:
        c_id = c_path[-1]
        c_version = None

    if c_id in c_compiler.keys():
        # cxx compiler was passed,
        # replace the name by the corresponding c compiler.
        cxx = args.compiler
        c_name = c_id
        cc_name = c_compiler[c_id]
        if c_version:
            cc_name += "-%s" % (c_version)
        cc = "/".join(c_path[:-1] + [cc_name])

    elif c_id in c_compiler.values():
        # c compiler was passed, get cxx name.
        cc = args.compiler
        cxx_name = [k for k, v in c_compiler.items() if v == c_id][0]
        c_name = cxx_name
        if c_version:
            cxx_name += "-%s" % (c_version)
        cxx = "/".join(c_path[:-1] + [cxx_name])

    else:
        # give up and just accept the compiler name
        cc = cxx = args.compiler
        c_name = "unknown-cc"

defines.update(c_compiler=cc, cxx_compiler=cxx)

# args.flags, args.ldflags, args.excessive_optimization
flags = shlex.split(args.flags)
ldflags = shlex.split(args.ldflags)

# if no flags have been given, populate them from the other args
if not flags and not ldflags:
    if mode == 'debug':
        if cc == 'gcc':
            flags.append("-Og")
        elif cc == 'clang':
            flags.append("-O1")
    elif mode == 'release':
        flags.append("-O2")
    elif mode == 'excessively_optimized':
        flags.append("-O3")
        flags.append("-march=native")
        if cc in {'gcc'}:
            flags.append("-flto=%d" % cpu_count())
            ldflags.append("-flto=%d" % cpu_count())

flags = shlex.join(flags)
ldflags = shlex.join(ldflags)
defines.update(c_flags=flags, cxx_flags=flags, exe_linker_flags=ldflags,
               module_linker_flags=ldflags, shared_linker_flags=ldflags)

# args.prefix
defines.update(install_prefix=args.prefix)

# create the build dir and symlink it to 'bin'
bindir = ".bin/%s/%s-%s" % (mode, cc, "".join(c for c in flags if c.isalnum()))
os.makedirs(bindir, exist_ok=True)
if os.path.exists('bin'):
    os.unlink('bin')
os.symlink(bindir, 'bin')

# create a symlink to the binary
if os.path.exists('openage'):
    os.unlink('openage')
os.symlink('%s/src/openage' % bindir, 'openage')

# the project root directory contains this configure file.
project_root = os.path.dirname(os.path.realpath(__file__))

# calculate cmake invocation from defines dict
invocation = ['cmake']
maxkeylen = max(len(k) for k in defines)
for k, v in sorted(defines.items()):
    print('%s | %s' % (k.rjust(maxkeylen), v))

    # work around this cmake 'feature':
    # when run in an existing build directory, if CC or CXX are given, all
    # other arguments are ignored... this is retarded.
    if os.path.exists(os.path.join(bindir, 'CMakeCache.txt')):
        if k in ('c_compiler', 'cxx_compiler'):
            # ignore the compiler setting.
            # as a new compiler name would result in
            # another build directory.
            continue

    invocation.append('-DCMAKE_%s=%s' % (k.upper(), shlex.quote(v)))

invocation.append('--')
invocation.append(project_root)

# switch to build directory
print('\nbindir:\n%s/\n' % os.path.join(project_root, bindir))
os.chdir(bindir)

# invoke cmake
try:
    print('invocation:\n%s' % ' '.join(invocation))
    exit(subprocess.call(invocation))
except FileNotFoundError:
    print("cmake was not found. it is a build dependency for openage.")
    exit(1)
