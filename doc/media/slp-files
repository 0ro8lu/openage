SLP media files
===============


slp files are stored in the graphics.drs

they contain all the (animation) textures.


slp files for movable objects
-----------------------------

for unit slp files, 5 states are stored:

0) Attacking
1) Standing Ground
2) Dying
3) Rotting
4) Moving

each state has ~50 textures for the animation -> ~250 textures per unit

for each animation, 5 directions of it are stored.

villagers have way more than the 5 animations, boats have 2.


slp files for static objects
----------------------------

contain the image of the building..

some static objects have multiple chunks, as moving creep can pass them somehow.


slp files for weapons
----------------------

for dust, arrows, etc.


slp files for shadows
---------------------

every object in game has a shadow. moving units have frames for their shadow in the same slp,
but buildings and other objects have their shadows in seperate slps.

-> large numbers of shadow SLPs unidentifable.



SLP file format
===============

the slp file starts with a header:

struct slp_header {
 char  version[4];
 int   num_frames;
 char  comment[24];
};

slp_header = Struct("< 4s i 24s")


after the header, there are num_frames entries of slp_frame_info.

struct slp_frame_info {
 unsigned int cmd_table_offset;
 unsigned int outline_table_offset;
 unsigned int palette_offset;
 unsigned int properties; //changes palette to use, but still unknown..
 int          width;
 int          height;
 int          hotspot_x; //center of the unit
 int          hotspot_y; //is referenced as the unit location by the engine
};

slp_frame_info = Struct("< I I I I i i i i")


slp_frame_info stores metainformation about one single frame (texture) within the slp.


after the frame infos, num_frames of images follow.


one image of size width x height has height rows.

at outline_table_offset, an array of slp_frame_row_edge structs begins, length = height.

struct slp_frame_row_edge {
 unsigned short left;
 unsigned short right;
};

slp_frame_row_edge = Struct("< H H")

the right or left value is 0x8000 if the row is completely transparent.
no command bytes end these transparent rows.

else, left and right specify the number of transparent pixel, from each side to the center.


after those padding frames, an array of 4byte-ints follows, length = height.
each int defines the offset for commands for each row.
int[0] is the first drawing command for the image.

these are not actually necessary to check, the commands can be read sequentially.
the command locations can be used for checking purposes though.



at cmd_table_offset the command data itself begins.



slp drawing commands
====================

the image is drawn line by line, a line is finished with command eol.

a command is a one-byte number followed by command-specific data.

the command byte can contain command data.

e.g. color_list command (0x00) only checks the least-significant bits to  command type and the rest of the byte is the number of palette indices to follow.
a command is parsed, data values after it are drawn, then the next command byte is reached.

each commands triggers a drawing method for n=pixel_count pixels.


pixel_count value:
  next           = next_byte after command
  >>2            = cmd_byte shifted 2 times right
  >>n|next       = pixel_count = cmd_byte >> n; if pixel_count == 0: pixel_count = next_byte
                   -> 8-n most significant bits of cmd_byte if they are != 0, else next byte.
  >>4*256 + next = (cmd_byte & 0xf0 << 4) + next_byte


command_name     cmd_byte  pixel_count     description
-----------------------------------------------------
color_list         = 0x00, >>2            for count: (palette_index=next, draw color)
skip               = 0x01, >>2|next       for count: (draw transparent pixel)
big_color_list     = 0x02, 4*256 + next   for count: (palette_index=next, draw this color)
big_skip           = 0x03, 4*256 + next   for count: (draw even more transparent pixels)
player_color_list  = 0x06, >>4|next       for count: (palette_index=next+(player*16))
fill               = 0x07, >>4|next       palette_index=next, for count: (draw)
fill_player_color  = 0x0A, >>4|next       palette_index=next+(player*16), for count: (draw)
shadow_transparent = 0x0B, >>4|next       for count: (draw transparent shadow)
eol                = 0x0F, 0              end of commands for this row
 -extended cmds:
shadow_player      = 0x0E, next           draw if sprite !xflipped (undocumented)
shadow_player      = 0x1E, next           draw if sprite xflipped  (undocumented)
shadow_player      = 0x2E, next           transform color tables   (undocumented)
selected           = 0x4E, 1              this single pixel gets replaced with the player color if obstructed
                                           -> op==4E: palette_index = 0
                                           -> op==6E: palette_index = player_index = player*16
selected_span      = 0x5E  next           same obstruction, supporting multiple pixels
                                           -> op==5E: palette_index = 0
                                           -> op==7E: player_color = palette_index = player*16


0x3E == 0x2E -> same opcode
0x6E == 0x4E
0x7E == 0x5E

note that commands with pixel_count == >>n do reuse the most significant bits of cmd_byte.
=> check the match for 8-n least significant bits only!

drawing shadows is like drawing black, but with alpha=0.5 or so.


with this information it's possible to draw palette_index correctly, but what is palette_index?


palette_index
=============

the drawing palette is stored inside the interfac.drs.

the offset is 50500+x, the palettes (color tables) are stored there.

x is the palette index, which should be 0, experiment with [1,10]...

interfac.drs contains many of these files, but the ingame art uses offset 50500.

the palette is a jasc paint shop pro file, starting with "JASC-PAL\r\n".
read this line at the offset to verify existance.
next line stores version information, can be ignored.
next line stores number of entries, important.

now follow "x y z\r\n" lines, storing 24bit a color tuple.

index these, they are the references in the slp file.



you should now be able to draw stuff.