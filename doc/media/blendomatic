blendomatic
===========


or: how to merge terrain tile edges.



alpha masks, that hide parts of terrain tiles, are stored in blendomatic.dat.





blendomatic.dat file format
---------------------------

struct {
	struct {
		unsigned int nr_blending_modes;   //normally 9
		unsigned int nr_tiles;            //normally 31
	} blendomatic_header;

	struct {
		struct {
			unsigned int  tile_size;      //normally 2353
			unsigned char tile_flags[nr_tiles];
			struct {
				bit alpha_bitmasks[tile_size];  //32 tiles, with tile_size pixels, use the data bitwise.
			} alpha_bitmasks[32];  //why 32?
		} blendingmode_header;

		struct {
			unsigned char pixeldata[tile_size];
		} tiledata[nr_of_tiles];
	} blending_modes[nr_blending_modes]
} blendomatic.dat;

this is our drawing goal (of course a bit bigger).

    *
  *****
*********
  *****
    *

the pixeldata array contains values to be drawn as *
we have to add the spaces ourselve.

each * is a pixel, with one byte value, which just is an alpha value.

with the default tile_size, we end up drawing the rhombus with 49 rows.


this is then used to overlay on a regular terrain tile, so that parts are alphamasked.

alpha_bitmasks selects which bytes from each tile are used,
the pixeldata determines how much to blend.


possible blending positions
---------------------------

4 sides + 4 corners + sides covering adjacent corners

TODO: visualize all the 31 blending cases




blending technique
------------------

drawing and blending in flat elevation.
sloped tiles: generated by texture mapping the flat tiles and lighting them (HSV color space)
blending is RGB space, blending them in HSV space coult reduced the amount of grey.

two terrains side by side in a straight line:
4 different tile blend patterns, minimizing the appearance of obvious tile repeating.
=> "straight blend", use the low 2 bits of the tile's X or y coordinate




additional nonverified information:

view_icn.dat
------------

=> get best color_palette entry
rgb to palette index transformation table with 10 variations of brightness

32 x 10 matrix of 32 x 32 pixel tiles.

brightness variation: use row 0..9

closest color index in the color_table for a given rgb (3*8 bit) value.
select one row, divide the values by 8 => coordinates in the table:

x = r * 32 + g
y = i * 32 + b

i == brightness, value = [0,9]



tileedge.dat / blkedge.dat format
---------------------------------


struct tile_edge {
	uint32_t elevation_offsets[17];
	struct {
		uint32_t tile_offsets[94];
		struct {
			struct {
				uint8 y;   // 0 <= y <= 72
				uint8 x0;  // 0 <= x0 <= 96
				uint8 x1;  // 0 <= x1 <= 96 && x0 <= x1
			} spans[n];    // repeat until y == 255
		} tiles[94];       // each starting at tile_offsets[i]
	} elevations[17];      // each starting at elevation_offsets[i]
}

blkedge.dat: replace 94 with 47, otherwise same format.

each 'spans' == pixels from (x0,y) to (x1,y) (inclusive) to set to 1;
=> 17*94 tiles, each 97x73 1-bit pixels
